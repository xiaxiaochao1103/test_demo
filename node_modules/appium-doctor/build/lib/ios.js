"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.OptionalApplesimutilsCommandCheck = exports.OptionalIdbCommandCheck = exports.CarthageCheck = exports.AuthorizationDbCheck = exports.DevToolsSecurityCheck = exports.XcodeCmdLineToolsCheck = exports.XcodeCheck = exports.fixes = void 0;

require("source-map-support/register");

var _utils = require("./utils");

var _appiumSupport = require("appium-support");

var _teen_process = require("teen_process");

var _doctor = require("./doctor");

var _logger = _interopRequireDefault(require("./logger"));

var _carthageDetector = _interopRequireDefault(require("./carthage-detector"));

var _prompt = require("./prompt");

var _env = _interopRequireDefault(require("./env"));

var _lodash = _interopRequireDefault(require("lodash"));

require("colors");

let checks = [];
let fixes = {};
exports.fixes = fixes;

class XcodeCheck extends _doctor.DoctorCheck {
  async diagnose() {
    let xcodePath;

    try {
      await (0, _teen_process.exec)('xcrun', ['simctl', 'help']);
      const {
        stdout
      } = await (0, _teen_process.exec)('xcode-select', ['-p']);
      xcodePath = (stdout || '').replace('\n', '');
    } catch (err) {
      return (0, _utils.nok)('Xcode is NOT installed!');
    }

    return xcodePath && (await _appiumSupport.fs.exists(xcodePath)) ? (0, _utils.ok)(`Xcode is installed at: ${xcodePath}`) : (0, _utils.nok)(`Xcode cannot be found at '${xcodePath}'!`);
  }

  async fix() {
    return `Manually install ${'Xcode'.bold}, and make sure 'xcode-select -p' command shows proper path like '/Applications/Xcode.app/Contents/Developer'`;
  }

}

exports.XcodeCheck = XcodeCheck;
checks.push(new XcodeCheck());

class XcodeCmdLineToolsCheck extends _doctor.DoctorCheck {
  constructor() {
    super({
      autofix: true
    });
  }

  async diagnose() {
    const errMess = 'Xcode Command Line Tools are NOT installed!';

    try {
      const stdout = (await (0, _teen_process.exec)('xcode-select', ['-p'])).stdout;
      return (0, _utils.ok)(`Xcode Command Line Tools are installed in: ${stdout.trim()}`);
    } catch (err) {
      _logger.default.debug(err);

      return (0, _utils.nok)(errMess);
    }
  }

  async fix() {
    _logger.default.info(`The following command need be executed: xcode-select --install`);

    let yesno = await (0, _prompt.fixIt)();

    if (yesno === 'yes') {
      await (0, _teen_process.exec)('xcode-select', ['--install']);
    } else {
      _logger.default.info(`Skipping you will need to install ${'Xcode'.bold} manually.`);

      throw new _doctor.FixSkippedError();
    }
  }

}

exports.XcodeCmdLineToolsCheck = XcodeCmdLineToolsCheck;
checks.push(new XcodeCmdLineToolsCheck());

fixes.authorizeIosFix = async function () {
  _logger.default.info(`The authorize iOS script need to be run.`);

  let yesno = await (0, _prompt.fixIt)();

  if (yesno === 'yes') {
    await (0, _utils.authorizeIos)();
  } else {
    _logger.default.info(`Skipping you will need to run ${'the authorize iOS'.bold} manually.`);

    throw new _doctor.FixSkippedError();
  }
};

class DevToolsSecurityCheck extends _doctor.DoctorCheck {
  constructor() {
    super({
      autofix: true
    });
  }

  async diagnose() {
    const errMess = 'DevToolsSecurity is NOT enabled!';
    let stdout;

    try {
      stdout = (await (0, _teen_process.exec)('DevToolsSecurity', [])).stdout;
    } catch (err) {
      _logger.default.debug(err);

      return (0, _utils.nok)(errMess);
    }

    return stdout && stdout.match(/enabled/) ? (0, _utils.ok)('DevToolsSecurity is enabled.') : (0, _utils.nok)(errMess);
  }

  async fix() {
    return await fixes.authorizeIosFix();
  }

}

exports.DevToolsSecurityCheck = DevToolsSecurityCheck;
checks.push(new DevToolsSecurityCheck());

class AuthorizationDbCheck extends _doctor.DoctorCheck {
  constructor() {
    super({
      autofix: true
    });
  }

  async diagnose() {
    const successMess = 'The Authorization DB is set up properly.';
    const errMess = 'The Authorization DB is NOT set up properly.';
    let stdout;

    try {
      ({
        stdout
      } = await (0, _teen_process.exec)('security', ['authorizationdb', 'read', 'system.privilege.taskport']));
    } catch (err) {
      _logger.default.warn(err);

      return (0, _utils.nok)(errMess);
    }

    return stdout && (stdout.match(/is-developer/) || stdout.match(/allow/)) ? (0, _utils.ok)(successMess) : (0, _utils.nok)(errMess);
  }

  async fix() {
    return await fixes.authorizeIosFix();
  }

}

exports.AuthorizationDbCheck = AuthorizationDbCheck;
checks.push(new AuthorizationDbCheck());

class CarthageCheck extends _doctor.DoctorCheck {
  async diagnose() {
    let carthagePath = await _carthageDetector.default.detect();
    let version;

    if (carthagePath) {
      try {
        const {
          stdout
        } = await (0, _teen_process.exec)(carthagePath, ['version']);
        version = _lodash.default.last(stdout.match(/(\d+\.\d+\.\d+)/g));

        if (!_appiumSupport.util.coerceVersion(version, false)) {
          _logger.default.warn(`Cannot parse Carthage version from ${stdout}`);
        }
      } catch (err) {
        _logger.default.warn(err);
      }
    }

    return carthagePath ? (0, _utils.ok)(`Carthage was found at: ${carthagePath}${version ? `. Installed version is: ${version}` : ''}`) : (0, _utils.nok)(`Carthage was NOT found!`);
  }

  async fix() {
    return `Please install ${'Carthage'.bold}. Visit https://github.com/Carthage` + '/Carthage#installing-carthage for more information.';
  }

}

exports.CarthageCheck = CarthageCheck;
checks.push(new CarthageCheck());
checks.push(new _env.default('HOME'));

class OptionalIdbCommandCheck extends _doctor.DoctorCheck {
  async diagnose() {
    const fbIdbPath = await (0, _utils.resolveExecutablePath)('idb');
    const fbCompanionIdbPath = await (0, _utils.resolveExecutablePath)('idb_companion');

    if (fbIdbPath && fbCompanionIdbPath) {
      return (0, _utils.okOptional)('idb and idb_companion are installed');
    }

    if (!fbIdbPath && fbCompanionIdbPath) {
      return (0, _utils.nokOptional)('idb is not installed');
    } else if (fbIdbPath && !fbCompanionIdbPath) {
      return (0, _utils.nokOptional)('idb_companion is not installed');
    }

    return (0, _utils.nokOptional)('idb and idb_companion are not installed');
  }

  async fix() {
    return `Why ${'idb'.bold} is needed and how to install it: https://github.com/appium/appium-idb`;
  }

}

exports.OptionalIdbCommandCheck = OptionalIdbCommandCheck;
checks.push(new OptionalIdbCommandCheck());

class OptionalApplesimutilsCommandCheck extends _doctor.DoctorCheck {
  async diagnose() {
    const applesimutilsPath = await (0, _utils.resolveExecutablePath)('applesimutils');
    return applesimutilsPath ? (0, _utils.okOptional)(`applesimutils is installed at: ${applesimutilsPath}. Installed versions are: ${(await (0, _teen_process.exec)('brew', ['list', '--versions', 'applesimutils'])).stdout.trim()}`) : (0, _utils.nokOptional)('applesimutils cannot be found');
  }

  async fix() {
    return `Why ${'applesimutils'.bold} is needed and how to install it: http://appium.io/docs/en/drivers/ios-xcuitest/`;
  }

}

exports.OptionalApplesimutilsCommandCheck = OptionalApplesimutilsCommandCheck;
checks.push(new OptionalApplesimutilsCommandCheck());
var _default = checks;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9pb3MuanMiXSwibmFtZXMiOlsiY2hlY2tzIiwiZml4ZXMiLCJYY29kZUNoZWNrIiwiRG9jdG9yQ2hlY2siLCJkaWFnbm9zZSIsInhjb2RlUGF0aCIsInN0ZG91dCIsInJlcGxhY2UiLCJlcnIiLCJmcyIsImV4aXN0cyIsImZpeCIsImJvbGQiLCJwdXNoIiwiWGNvZGVDbWRMaW5lVG9vbHNDaGVjayIsImNvbnN0cnVjdG9yIiwiYXV0b2ZpeCIsImVyck1lc3MiLCJ0cmltIiwibG9nIiwiZGVidWciLCJpbmZvIiwieWVzbm8iLCJGaXhTa2lwcGVkRXJyb3IiLCJhdXRob3JpemVJb3NGaXgiLCJEZXZUb29sc1NlY3VyaXR5Q2hlY2siLCJtYXRjaCIsIkF1dGhvcml6YXRpb25EYkNoZWNrIiwic3VjY2Vzc01lc3MiLCJ3YXJuIiwiQ2FydGhhZ2VDaGVjayIsImNhcnRoYWdlUGF0aCIsIkNhcnRoYWdlRGV0ZWN0b3IiLCJkZXRlY3QiLCJ2ZXJzaW9uIiwiXyIsImxhc3QiLCJ1dGlsIiwiY29lcmNlVmVyc2lvbiIsIkVudlZhckFuZFBhdGhDaGVjayIsIk9wdGlvbmFsSWRiQ29tbWFuZENoZWNrIiwiZmJJZGJQYXRoIiwiZmJDb21wYW5pb25JZGJQYXRoIiwiT3B0aW9uYWxBcHBsZXNpbXV0aWxzQ29tbWFuZENoZWNrIiwiYXBwbGVzaW11dGlsc1BhdGgiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUEsSUFBSUEsTUFBTSxHQUFHLEVBQWI7QUFDQSxJQUFJQyxLQUFLLEdBQUcsRUFBWjs7O0FBR0EsTUFBTUMsVUFBTixTQUF5QkMsbUJBQXpCLENBQXFDO0FBQ25DLFFBQU1DLFFBQU4sR0FBa0I7QUFDaEIsUUFBSUMsU0FBSjs7QUFDQSxRQUFJO0FBRUYsWUFBTSx3QkFBSyxPQUFMLEVBQWMsQ0FBQyxRQUFELEVBQVcsTUFBWCxDQUFkLENBQU47QUFFQSxZQUFNO0FBQUNDLFFBQUFBO0FBQUQsVUFBVyxNQUFNLHdCQUFLLGNBQUwsRUFBcUIsQ0FBQyxJQUFELENBQXJCLENBQXZCO0FBQ0FELE1BQUFBLFNBQVMsR0FBRyxDQUFDQyxNQUFNLElBQUksRUFBWCxFQUFlQyxPQUFmLENBQXVCLElBQXZCLEVBQTZCLEVBQTdCLENBQVo7QUFDRCxLQU5ELENBTUUsT0FBT0MsR0FBUCxFQUFZO0FBQ1osYUFBTyxnQkFBSSx5QkFBSixDQUFQO0FBQ0Q7O0FBQ0QsV0FBT0gsU0FBUyxLQUFJLE1BQU1JLGtCQUFHQyxNQUFILENBQVVMLFNBQVYsQ0FBVixDQUFULEdBQTBDLGVBQUksMEJBQXlCQSxTQUFVLEVBQXZDLENBQTFDLEdBQ0wsZ0JBQUssNkJBQTRCQSxTQUFVLElBQTNDLENBREY7QUFFRDs7QUFFRCxRQUFNTSxHQUFOLEdBQWE7QUFDWCxXQUFRLG9CQUFtQixRQUFRQyxJQUFLLCtHQUF4QztBQUNEOztBQWxCa0M7OztBQW9CckNaLE1BQU0sQ0FBQ2EsSUFBUCxDQUFZLElBQUlYLFVBQUosRUFBWjs7QUFHQSxNQUFNWSxzQkFBTixTQUFxQ1gsbUJBQXJDLENBQWlEO0FBQy9DWSxFQUFBQSxXQUFXLEdBQUk7QUFDYixVQUFNO0FBQUNDLE1BQUFBLE9BQU8sRUFBRTtBQUFWLEtBQU47QUFDRDs7QUFFRCxRQUFNWixRQUFOLEdBQWtCO0FBQ2hCLFVBQU1hLE9BQU8sR0FBRyw2Q0FBaEI7O0FBQ0EsUUFBSTtBQUVGLFlBQU1YLE1BQU0sR0FBRyxDQUFDLE1BQU0sd0JBQUssY0FBTCxFQUFxQixDQUFDLElBQUQsQ0FBckIsQ0FBUCxFQUFxQ0EsTUFBcEQ7QUFDQSxhQUFPLGVBQUksOENBQTZDQSxNQUFNLENBQUNZLElBQVAsRUFBYyxFQUEvRCxDQUFQO0FBQ0QsS0FKRCxDQUlFLE9BQU9WLEdBQVAsRUFBWTtBQUNaVyxzQkFBSUMsS0FBSixDQUFVWixHQUFWOztBQUNBLGFBQU8sZ0JBQUlTLE9BQUosQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQsUUFBTU4sR0FBTixHQUFhO0FBQ1hRLG9CQUFJRSxJQUFKLENBQVUsZ0VBQVY7O0FBQ0EsUUFBSUMsS0FBSyxHQUFHLE1BQU0sb0JBQWxCOztBQUNBLFFBQUlBLEtBQUssS0FBSyxLQUFkLEVBQXFCO0FBQ25CLFlBQU0sd0JBQUssY0FBTCxFQUFxQixDQUFDLFdBQUQsQ0FBckIsQ0FBTjtBQUNELEtBRkQsTUFFTztBQUNMSCxzQkFBSUUsSUFBSixDQUFVLHFDQUFvQyxRQUFRVCxJQUFLLFlBQTNEOztBQUNBLFlBQU0sSUFBSVcsdUJBQUosRUFBTjtBQUNEO0FBQ0Y7O0FBMUI4Qzs7O0FBNkJqRHZCLE1BQU0sQ0FBQ2EsSUFBUCxDQUFZLElBQUlDLHNCQUFKLEVBQVo7O0FBR0FiLEtBQUssQ0FBQ3VCLGVBQU4sR0FBd0Isa0JBQWtCO0FBQ3hDTCxrQkFBSUUsSUFBSixDQUFVLDBDQUFWOztBQUNBLE1BQUlDLEtBQUssR0FBRyxNQUFNLG9CQUFsQjs7QUFDQSxNQUFJQSxLQUFLLEtBQUssS0FBZCxFQUFxQjtBQUNuQixVQUFNLDBCQUFOO0FBQ0QsR0FGRCxNQUVPO0FBQ0xILG9CQUFJRSxJQUFKLENBQVUsaUNBQWdDLG9CQUFvQlQsSUFBSyxZQUFuRTs7QUFDQSxVQUFNLElBQUlXLHVCQUFKLEVBQU47QUFDRDtBQUNGLENBVEQ7O0FBWUEsTUFBTUUscUJBQU4sU0FBb0N0QixtQkFBcEMsQ0FBZ0Q7QUFDOUNZLEVBQUFBLFdBQVcsR0FBSTtBQUNiLFVBQU07QUFBQ0MsTUFBQUEsT0FBTyxFQUFFO0FBQVYsS0FBTjtBQUNEOztBQUVELFFBQU1aLFFBQU4sR0FBa0I7QUFDaEIsVUFBTWEsT0FBTyxHQUFHLGtDQUFoQjtBQUNBLFFBQUlYLE1BQUo7O0FBQ0EsUUFBSTtBQUNGQSxNQUFBQSxNQUFNLEdBQUcsQ0FBQyxNQUFNLHdCQUFLLGtCQUFMLEVBQXlCLEVBQXpCLENBQVAsRUFBcUNBLE1BQTlDO0FBQ0QsS0FGRCxDQUVFLE9BQU9FLEdBQVAsRUFBWTtBQUNaVyxzQkFBSUMsS0FBSixDQUFVWixHQUFWOztBQUNBLGFBQU8sZ0JBQUlTLE9BQUosQ0FBUDtBQUNEOztBQUNELFdBQU9YLE1BQU0sSUFBSUEsTUFBTSxDQUFDb0IsS0FBUCxDQUFhLFNBQWIsQ0FBVixHQUFvQyxlQUFHLDhCQUFILENBQXBDLEdBQ0gsZ0JBQUlULE9BQUosQ0FESjtBQUVEOztBQUNELFFBQU1OLEdBQU4sR0FBYTtBQUNYLFdBQU8sTUFBTVYsS0FBSyxDQUFDdUIsZUFBTixFQUFiO0FBQ0Q7O0FBbkI2Qzs7O0FBcUJoRHhCLE1BQU0sQ0FBQ2EsSUFBUCxDQUFZLElBQUlZLHFCQUFKLEVBQVo7O0FBR0EsTUFBTUUsb0JBQU4sU0FBbUN4QixtQkFBbkMsQ0FBK0M7QUFDN0NZLEVBQUFBLFdBQVcsR0FBSTtBQUNiLFVBQU07QUFBQ0MsTUFBQUEsT0FBTyxFQUFFO0FBQVYsS0FBTjtBQUNEOztBQUVELFFBQU1aLFFBQU4sR0FBa0I7QUFDaEIsVUFBTXdCLFdBQVcsR0FBRywwQ0FBcEI7QUFDQSxVQUFNWCxPQUFPLEdBQUcsOENBQWhCO0FBQ0EsUUFBSVgsTUFBSjs7QUFDQSxRQUFJO0FBQ0YsT0FBQztBQUFDQSxRQUFBQTtBQUFELFVBQVcsTUFBTSx3QkFBSyxVQUFMLEVBQWlCLENBQUMsaUJBQUQsRUFBb0IsTUFBcEIsRUFBNEIsMkJBQTVCLENBQWpCLENBQWxCO0FBQ0QsS0FGRCxDQUVFLE9BQU9FLEdBQVAsRUFBWTtBQUNaVyxzQkFBSVUsSUFBSixDQUFTckIsR0FBVDs7QUFDQSxhQUFPLGdCQUFJUyxPQUFKLENBQVA7QUFDRDs7QUFDRCxXQUFPWCxNQUFNLEtBQUtBLE1BQU0sQ0FBQ29CLEtBQVAsQ0FBYSxjQUFiLEtBQWdDcEIsTUFBTSxDQUFDb0IsS0FBUCxDQUFhLE9BQWIsQ0FBckMsQ0FBTixHQUNMLGVBQUdFLFdBQUgsQ0FESyxHQUNhLGdCQUFJWCxPQUFKLENBRHBCO0FBRUQ7O0FBQ0QsUUFBTU4sR0FBTixHQUFhO0FBQ1gsV0FBTyxNQUFNVixLQUFLLENBQUN1QixlQUFOLEVBQWI7QUFDRDs7QUFwQjRDOzs7QUFzQi9DeEIsTUFBTSxDQUFDYSxJQUFQLENBQVksSUFBSWMsb0JBQUosRUFBWjs7QUFHQSxNQUFNRyxhQUFOLFNBQTRCM0IsbUJBQTVCLENBQXdDO0FBQ3RDLFFBQU1DLFFBQU4sR0FBa0I7QUFDaEIsUUFBSTJCLFlBQVksR0FBRyxNQUFNQywwQkFBaUJDLE1BQWpCLEVBQXpCO0FBRUEsUUFBSUMsT0FBSjs7QUFDQSxRQUFJSCxZQUFKLEVBQWtCO0FBQ2hCLFVBQUk7QUFDRixjQUFNO0FBQUN6QixVQUFBQTtBQUFELFlBQVcsTUFBTSx3QkFBS3lCLFlBQUwsRUFBbUIsQ0FBQyxTQUFELENBQW5CLENBQXZCO0FBR0FHLFFBQUFBLE9BQU8sR0FBR0MsZ0JBQUVDLElBQUYsQ0FBTzlCLE1BQU0sQ0FBQ29CLEtBQVAsQ0FBYSxrQkFBYixDQUFQLENBQVY7O0FBQ0EsWUFBSSxDQUFDVyxvQkFBS0MsYUFBTCxDQUFtQkosT0FBbkIsRUFBNEIsS0FBNUIsQ0FBTCxFQUF5QztBQUN2Q2YsMEJBQUlVLElBQUosQ0FBVSxzQ0FBcUN2QixNQUFPLEVBQXREO0FBQ0Q7QUFDRixPQVJELENBUUUsT0FBT0UsR0FBUCxFQUFZO0FBQ1pXLHdCQUFJVSxJQUFKLENBQVNyQixHQUFUO0FBQ0Q7QUFDRjs7QUFFRCxXQUFPdUIsWUFBWSxHQUNmLGVBQUksMEJBQXlCQSxZQUFhLEdBQUdHLE9BQU8sR0FBSSwyQkFBMEJBLE9BQVEsRUFBdEMsR0FBMEMsRUFBRyxFQUFqRyxDQURlLEdBRWYsZ0JBQUsseUJBQUwsQ0FGSjtBQUdEOztBQUVELFFBQU12QixHQUFOLEdBQWE7QUFDWCxXQUFRLGtCQUFpQixXQUFXQyxJQUFLLHFDQUFsQyxHQUNBLHFEQURQO0FBRUQ7O0FBM0JxQzs7O0FBNkJ4Q1osTUFBTSxDQUFDYSxJQUFQLENBQVksSUFBSWlCLGFBQUosRUFBWjtBQUVBOUIsTUFBTSxDQUFDYSxJQUFQLENBQVksSUFBSTBCLFlBQUosQ0FBdUIsTUFBdkIsQ0FBWjs7QUFFQSxNQUFNQyx1QkFBTixTQUFzQ3JDLG1CQUF0QyxDQUFrRDtBQUNoRCxRQUFNQyxRQUFOLEdBQWtCO0FBQ2hCLFVBQU1xQyxTQUFTLEdBQUcsTUFBTSxrQ0FBc0IsS0FBdEIsQ0FBeEI7QUFDQSxVQUFNQyxrQkFBa0IsR0FBRyxNQUFNLGtDQUFzQixlQUF0QixDQUFqQzs7QUFDQSxRQUFJRCxTQUFTLElBQUlDLGtCQUFqQixFQUFxQztBQUNuQyxhQUFPLHVCQUFXLHFDQUFYLENBQVA7QUFDRDs7QUFFRCxRQUFJLENBQUNELFNBQUQsSUFBY0Msa0JBQWxCLEVBQXNDO0FBQ3BDLGFBQU8sd0JBQVksc0JBQVosQ0FBUDtBQUNELEtBRkQsTUFFTyxJQUFJRCxTQUFTLElBQUksQ0FBQ0Msa0JBQWxCLEVBQXNDO0FBQzNDLGFBQU8sd0JBQVksZ0NBQVosQ0FBUDtBQUNEOztBQUNELFdBQU8sd0JBQVkseUNBQVosQ0FBUDtBQUNEOztBQUVELFFBQU0vQixHQUFOLEdBQWE7QUFDWCxXQUFRLE9BQU0sTUFBTUMsSUFBSyx3RUFBekI7QUFDRDs7QUFsQitDOzs7QUFvQmxEWixNQUFNLENBQUNhLElBQVAsQ0FBWSxJQUFJMkIsdUJBQUosRUFBWjs7QUFFQSxNQUFNRyxpQ0FBTixTQUFnRHhDLG1CQUFoRCxDQUE0RDtBQUMxRCxRQUFNQyxRQUFOLEdBQWtCO0FBQ2hCLFVBQU13QyxpQkFBaUIsR0FBRyxNQUFNLGtDQUFzQixlQUF0QixDQUFoQztBQUNBLFdBQU9BLGlCQUFpQixHQUNwQix1QkFBWSxrQ0FBaUNBLGlCQUFrQiw2QkFBNEIsQ0FBQyxNQUFNLHdCQUFLLE1BQUwsRUFBYSxDQUFDLE1BQUQsRUFBUyxZQUFULEVBQXVCLGVBQXZCLENBQWIsQ0FBUCxFQUE4RHRDLE1BQTlELENBQXFFWSxJQUFyRSxFQUE0RSxFQUF2SyxDQURvQixHQUVwQix3QkFBWSwrQkFBWixDQUZKO0FBR0Q7O0FBRUQsUUFBTVAsR0FBTixHQUFhO0FBQ1gsV0FBUSxPQUFNLGdCQUFnQkMsSUFBSyxrRkFBbkM7QUFDRDs7QUFWeUQ7OztBQVk1RFosTUFBTSxDQUFDYSxJQUFQLENBQVksSUFBSThCLGlDQUFKLEVBQVo7ZUFNZTNDLE0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBvaywgbm9rLCBva09wdGlvbmFsLCBub2tPcHRpb25hbCwgYXV0aG9yaXplSW9zLCByZXNvbHZlRXhlY3V0YWJsZVBhdGggfSBmcm9tICcuL3V0aWxzJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuaW1wb3J0IHsgZnMsIHV0aWwgfSBmcm9tICdhcHBpdW0tc3VwcG9ydCc7XG5pbXBvcnQgeyBleGVjIH0gZnJvbSAndGVlbl9wcm9jZXNzJztcbmltcG9ydCB7IERvY3RvckNoZWNrLCBGaXhTa2lwcGVkRXJyb3IgfSBmcm9tICcuL2RvY3Rvcic7XG5pbXBvcnQgbG9nIGZyb20gJy4vbG9nZ2VyJztcbmltcG9ydCBDYXJ0aGFnZURldGVjdG9yIGZyb20gJy4vY2FydGhhZ2UtZGV0ZWN0b3InO1xuaW1wb3J0IHsgZml4SXQgfSBmcm9tICcuL3Byb21wdCc7XG5pbXBvcnQgRW52VmFyQW5kUGF0aENoZWNrIGZyb20gJy4vZW52JztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgJ2NvbG9ycyc7XG5cbmxldCBjaGVja3MgPSBbXTtcbmxldCBmaXhlcyA9IHt9O1xuXG4vLyBDaGVjayBmb3IgWGNvZGUuXG5jbGFzcyBYY29kZUNoZWNrIGV4dGVuZHMgRG9jdG9yQ2hlY2sge1xuICBhc3luYyBkaWFnbm9zZSAoKSB7XG4gICAgbGV0IHhjb2RlUGF0aDtcbiAgICB0cnkge1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FwcGl1bS9hcHBpdW0vaXNzdWVzLzEyMDkzI2lzc3VlY29tbWVudC00NTkzNTgxMjAgY2FuIGhhcHBlblxuICAgICAgYXdhaXQgZXhlYygneGNydW4nLCBbJ3NpbWN0bCcsICdoZWxwJ10pO1xuXG4gICAgICBjb25zdCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMoJ3hjb2RlLXNlbGVjdCcsIFsnLXAnXSk7XG4gICAgICB4Y29kZVBhdGggPSAoc3Rkb3V0IHx8ICcnKS5yZXBsYWNlKCdcXG4nLCAnJyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gbm9rKCdYY29kZSBpcyBOT1QgaW5zdGFsbGVkIScpO1xuICAgIH1cbiAgICByZXR1cm4geGNvZGVQYXRoICYmIGF3YWl0IGZzLmV4aXN0cyh4Y29kZVBhdGgpID8gb2soYFhjb2RlIGlzIGluc3RhbGxlZCBhdDogJHt4Y29kZVBhdGh9YCkgOlxuICAgICAgbm9rKGBYY29kZSBjYW5ub3QgYmUgZm91bmQgYXQgJyR7eGNvZGVQYXRofSchYCk7XG4gIH1cblxuICBhc3luYyBmaXggKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtYXdhaXRcbiAgICByZXR1cm4gYE1hbnVhbGx5IGluc3RhbGwgJHsnWGNvZGUnLmJvbGR9LCBhbmQgbWFrZSBzdXJlICd4Y29kZS1zZWxlY3QgLXAnIGNvbW1hbmQgc2hvd3MgcHJvcGVyIHBhdGggbGlrZSAnL0FwcGxpY2F0aW9ucy9YY29kZS5hcHAvQ29udGVudHMvRGV2ZWxvcGVyJ2A7XG4gIH1cbn1cbmNoZWNrcy5wdXNoKG5ldyBYY29kZUNoZWNrKCkpO1xuXG4vLyBDaGVjayBmb3IgWGNvZGUgQ29tbWFuZCBMaW5lIFRvb2xzLlxuY2xhc3MgWGNvZGVDbWRMaW5lVG9vbHNDaGVjayBleHRlbmRzIERvY3RvckNoZWNrIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKHthdXRvZml4OiB0cnVlfSk7XG4gIH1cblxuICBhc3luYyBkaWFnbm9zZSAoKSB7XG4gICAgY29uc3QgZXJyTWVzcyA9ICdYY29kZSBDb21tYW5kIExpbmUgVG9vbHMgYXJlIE5PVCBpbnN0YWxsZWQhJztcbiAgICB0cnkge1xuICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTUzNzE5MjUvaG93LXRvLWNoZWNrLWlmLWNvbW1hbmQtbGluZS10b29scy1pcy1pbnN0YWxsZWRcbiAgICAgIGNvbnN0IHN0ZG91dCA9IChhd2FpdCBleGVjKCd4Y29kZS1zZWxlY3QnLCBbJy1wJ10pKS5zdGRvdXQ7XG4gICAgICByZXR1cm4gb2soYFhjb2RlIENvbW1hbmQgTGluZSBUb29scyBhcmUgaW5zdGFsbGVkIGluOiAke3N0ZG91dC50cmltKCl9YCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2cuZGVidWcoZXJyKTtcbiAgICAgIHJldHVybiBub2soZXJyTWVzcyk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZml4ICgpIHtcbiAgICBsb2cuaW5mbyhgVGhlIGZvbGxvd2luZyBjb21tYW5kIG5lZWQgYmUgZXhlY3V0ZWQ6IHhjb2RlLXNlbGVjdCAtLWluc3RhbGxgKTtcbiAgICBsZXQgeWVzbm8gPSBhd2FpdCBmaXhJdCgpO1xuICAgIGlmICh5ZXNubyA9PT0gJ3llcycpIHtcbiAgICAgIGF3YWl0IGV4ZWMoJ3hjb2RlLXNlbGVjdCcsIFsnLS1pbnN0YWxsJ10pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2cuaW5mbyhgU2tpcHBpbmcgeW91IHdpbGwgbmVlZCB0byBpbnN0YWxsICR7J1hjb2RlJy5ib2xkfSBtYW51YWxseS5gKTtcbiAgICAgIHRocm93IG5ldyBGaXhTa2lwcGVkRXJyb3IoKTtcbiAgICB9XG4gIH1cbn1cblxuY2hlY2tzLnB1c2gobmV3IFhjb2RlQ21kTGluZVRvb2xzQ2hlY2soKSk7XG5cbi8vIEF1dG9tYXRpY2FsbHkgcnVuIGF1dGhvcml6ZSBpT1MgaWYgcmVxdWVzdGVkXG5maXhlcy5hdXRob3JpemVJb3NGaXggPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIGxvZy5pbmZvKGBUaGUgYXV0aG9yaXplIGlPUyBzY3JpcHQgbmVlZCB0byBiZSBydW4uYCk7XG4gIGxldCB5ZXNubyA9IGF3YWl0IGZpeEl0KCk7XG4gIGlmICh5ZXNubyA9PT0gJ3llcycpIHtcbiAgICBhd2FpdCBhdXRob3JpemVJb3MoKTtcbiAgfSBlbHNlIHtcbiAgICBsb2cuaW5mbyhgU2tpcHBpbmcgeW91IHdpbGwgbmVlZCB0byBydW4gJHsndGhlIGF1dGhvcml6ZSBpT1MnLmJvbGR9IG1hbnVhbGx5LmApO1xuICAgIHRocm93IG5ldyBGaXhTa2lwcGVkRXJyb3IoKTtcbiAgfVxufTtcblxuLy8gRGV2IFRvb2xzIFNlY3VyaXR5XG5jbGFzcyBEZXZUb29sc1NlY3VyaXR5Q2hlY2sgZXh0ZW5kcyBEb2N0b3JDaGVjayB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcih7YXV0b2ZpeDogdHJ1ZX0pO1xuICB9XG5cbiAgYXN5bmMgZGlhZ25vc2UgKCkge1xuICAgIGNvbnN0IGVyck1lc3MgPSAnRGV2VG9vbHNTZWN1cml0eSBpcyBOT1QgZW5hYmxlZCEnO1xuICAgIGxldCBzdGRvdXQ7XG4gICAgdHJ5IHtcbiAgICAgIHN0ZG91dCA9IChhd2FpdCBleGVjKCdEZXZUb29sc1NlY3VyaXR5JywgW10pKS5zdGRvdXQ7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2cuZGVidWcoZXJyKTtcbiAgICAgIHJldHVybiBub2soZXJyTWVzcyk7XG4gICAgfVxuICAgIHJldHVybiBzdGRvdXQgJiYgc3Rkb3V0Lm1hdGNoKC9lbmFibGVkLykgPyBvaygnRGV2VG9vbHNTZWN1cml0eSBpcyBlbmFibGVkLicpXG4gICAgICA6IG5vayhlcnJNZXNzKTtcbiAgfVxuICBhc3luYyBmaXggKCkge1xuICAgIHJldHVybiBhd2FpdCBmaXhlcy5hdXRob3JpemVJb3NGaXgoKTtcbiAgfVxufVxuY2hlY2tzLnB1c2gobmV3IERldlRvb2xzU2VjdXJpdHlDaGVjaygpKTtcblxuLy8gQXV0aG9yaXphdGlvbiBEQlxuY2xhc3MgQXV0aG9yaXphdGlvbkRiQ2hlY2sgZXh0ZW5kcyBEb2N0b3JDaGVjayB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcih7YXV0b2ZpeDogdHJ1ZX0pO1xuICB9XG5cbiAgYXN5bmMgZGlhZ25vc2UgKCkge1xuICAgIGNvbnN0IHN1Y2Nlc3NNZXNzID0gJ1RoZSBBdXRob3JpemF0aW9uIERCIGlzIHNldCB1cCBwcm9wZXJseS4nO1xuICAgIGNvbnN0IGVyck1lc3MgPSAnVGhlIEF1dGhvcml6YXRpb24gREIgaXMgTk9UIHNldCB1cCBwcm9wZXJseS4nO1xuICAgIGxldCBzdGRvdXQ7XG4gICAgdHJ5IHtcbiAgICAgICh7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMoJ3NlY3VyaXR5JywgWydhdXRob3JpemF0aW9uZGInLCAncmVhZCcsICdzeXN0ZW0ucHJpdmlsZWdlLnRhc2twb3J0J10pKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZy53YXJuKGVycik7XG4gICAgICByZXR1cm4gbm9rKGVyck1lc3MpO1xuICAgIH1cbiAgICByZXR1cm4gc3Rkb3V0ICYmIChzdGRvdXQubWF0Y2goL2lzLWRldmVsb3Blci8pIHx8IHN0ZG91dC5tYXRjaCgvYWxsb3cvKSkgP1xuICAgICAgb2soc3VjY2Vzc01lc3MpIDogbm9rKGVyck1lc3MpO1xuICB9XG4gIGFzeW5jIGZpeCAoKSB7XG4gICAgcmV0dXJuIGF3YWl0IGZpeGVzLmF1dGhvcml6ZUlvc0ZpeCgpO1xuICB9XG59XG5jaGVja3MucHVzaChuZXcgQXV0aG9yaXphdGlvbkRiQ2hlY2soKSk7XG5cbi8vIENoZWNrIGZvciBDYXJ0aGFnZSAoZm9yIFdEQSlcbmNsYXNzIENhcnRoYWdlQ2hlY2sgZXh0ZW5kcyBEb2N0b3JDaGVjayB7XG4gIGFzeW5jIGRpYWdub3NlICgpIHtcbiAgICBsZXQgY2FydGhhZ2VQYXRoID0gYXdhaXQgQ2FydGhhZ2VEZXRlY3Rvci5kZXRlY3QoKTtcblxuICAgIGxldCB2ZXJzaW9uO1xuICAgIGlmIChjYXJ0aGFnZVBhdGgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYyhjYXJ0aGFnZVBhdGgsIFsndmVyc2lvbiddKTtcbiAgICAgICAgLy8gJ1BsZWFzZSB1cGRhdGUgdG8gdGhlIGxhdGVzdCBDYXJ0aGFnZSB2ZXJzaW9uOiAwLjMzLjAuIFlvdSBjdXJyZW50bHkgYXJlIG9uIDAuMzIuMFxcbjAuMzIuMFxcbicgb3IgJzAuMzIuMFxcbidcbiAgICAgICAgLy8gMC4zMi4wIGlzIHRoZSBjdXJyZW50IHZlcnNpb24uIDAuMzMuMCBpcyBhbiBhdmFpbGFibGUgbmV3ZXIgdmVyc2lvbi5cbiAgICAgICAgdmVyc2lvbiA9IF8ubGFzdChzdGRvdXQubWF0Y2goLyhcXGQrXFwuXFxkK1xcLlxcZCspL2cpKTtcbiAgICAgICAgaWYgKCF1dGlsLmNvZXJjZVZlcnNpb24odmVyc2lvbiwgZmFsc2UpKSB7XG4gICAgICAgICAgbG9nLndhcm4oYENhbm5vdCBwYXJzZSBDYXJ0aGFnZSB2ZXJzaW9uIGZyb20gJHtzdGRvdXR9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2cud2FybihlcnIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjYXJ0aGFnZVBhdGhcbiAgICAgID8gb2soYENhcnRoYWdlIHdhcyBmb3VuZCBhdDogJHtjYXJ0aGFnZVBhdGh9JHsgdmVyc2lvbiA/IGAuIEluc3RhbGxlZCB2ZXJzaW9uIGlzOiAke3ZlcnNpb259YCA6ICcnfWApXG4gICAgICA6IG5vayhgQ2FydGhhZ2Ugd2FzIE5PVCBmb3VuZCFgKTtcbiAgfVxuXG4gIGFzeW5jIGZpeCAoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1hd2FpdFxuICAgIHJldHVybiBgUGxlYXNlIGluc3RhbGwgJHsnQ2FydGhhZ2UnLmJvbGR9LiBWaXNpdCBodHRwczovL2dpdGh1Yi5jb20vQ2FydGhhZ2VgICtcbiAgICAgICAgICAgJy9DYXJ0aGFnZSNpbnN0YWxsaW5nLWNhcnRoYWdlIGZvciBtb3JlIGluZm9ybWF0aW9uLic7XG4gIH1cbn1cbmNoZWNrcy5wdXNoKG5ldyBDYXJ0aGFnZUNoZWNrKCkpO1xuXG5jaGVja3MucHVzaChuZXcgRW52VmFyQW5kUGF0aENoZWNrKCdIT01FJykpO1xuXG5jbGFzcyBPcHRpb25hbElkYkNvbW1hbmRDaGVjayBleHRlbmRzIERvY3RvckNoZWNrIHtcbiAgYXN5bmMgZGlhZ25vc2UgKCkge1xuICAgIGNvbnN0IGZiSWRiUGF0aCA9IGF3YWl0IHJlc29sdmVFeGVjdXRhYmxlUGF0aCgnaWRiJyk7XG4gICAgY29uc3QgZmJDb21wYW5pb25JZGJQYXRoID0gYXdhaXQgcmVzb2x2ZUV4ZWN1dGFibGVQYXRoKCdpZGJfY29tcGFuaW9uJyk7XG4gICAgaWYgKGZiSWRiUGF0aCAmJiBmYkNvbXBhbmlvbklkYlBhdGgpIHtcbiAgICAgIHJldHVybiBva09wdGlvbmFsKCdpZGIgYW5kIGlkYl9jb21wYW5pb24gYXJlIGluc3RhbGxlZCcpO1xuICAgIH1cblxuICAgIGlmICghZmJJZGJQYXRoICYmIGZiQ29tcGFuaW9uSWRiUGF0aCkge1xuICAgICAgcmV0dXJuIG5va09wdGlvbmFsKCdpZGIgaXMgbm90IGluc3RhbGxlZCcpO1xuICAgIH0gZWxzZSBpZiAoZmJJZGJQYXRoICYmICFmYkNvbXBhbmlvbklkYlBhdGgpIHtcbiAgICAgIHJldHVybiBub2tPcHRpb25hbCgnaWRiX2NvbXBhbmlvbiBpcyBub3QgaW5zdGFsbGVkJyk7XG4gICAgfVxuICAgIHJldHVybiBub2tPcHRpb25hbCgnaWRiIGFuZCBpZGJfY29tcGFuaW9uIGFyZSBub3QgaW5zdGFsbGVkJyk7XG4gIH1cblxuICBhc3luYyBmaXggKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtYXdhaXRcbiAgICByZXR1cm4gYFdoeSAkeydpZGInLmJvbGR9IGlzIG5lZWRlZCBhbmQgaG93IHRvIGluc3RhbGwgaXQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9hcHBpdW0vYXBwaXVtLWlkYmA7XG4gIH1cbn1cbmNoZWNrcy5wdXNoKG5ldyBPcHRpb25hbElkYkNvbW1hbmRDaGVjaygpKTtcblxuY2xhc3MgT3B0aW9uYWxBcHBsZXNpbXV0aWxzQ29tbWFuZENoZWNrIGV4dGVuZHMgRG9jdG9yQ2hlY2sge1xuICBhc3luYyBkaWFnbm9zZSAoKSB7XG4gICAgY29uc3QgYXBwbGVzaW11dGlsc1BhdGggPSBhd2FpdCByZXNvbHZlRXhlY3V0YWJsZVBhdGgoJ2FwcGxlc2ltdXRpbHMnKTtcbiAgICByZXR1cm4gYXBwbGVzaW11dGlsc1BhdGhcbiAgICAgID8gb2tPcHRpb25hbChgYXBwbGVzaW11dGlscyBpcyBpbnN0YWxsZWQgYXQ6ICR7YXBwbGVzaW11dGlsc1BhdGh9LiBJbnN0YWxsZWQgdmVyc2lvbnMgYXJlOiAkeyhhd2FpdCBleGVjKCdicmV3JywgWydsaXN0JywgJy0tdmVyc2lvbnMnLCAnYXBwbGVzaW11dGlscyddKSkuc3Rkb3V0LnRyaW0oKX1gKVxuICAgICAgOiBub2tPcHRpb25hbCgnYXBwbGVzaW11dGlscyBjYW5ub3QgYmUgZm91bmQnKTtcbiAgfVxuXG4gIGFzeW5jIGZpeCAoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1hd2FpdFxuICAgIHJldHVybiBgV2h5ICR7J2FwcGxlc2ltdXRpbHMnLmJvbGR9IGlzIG5lZWRlZCBhbmQgaG93IHRvIGluc3RhbGwgaXQ6IGh0dHA6Ly9hcHBpdW0uaW8vZG9jcy9lbi9kcml2ZXJzL2lvcy14Y3VpdGVzdC9gO1xuICB9XG59XG5jaGVja3MucHVzaChuZXcgT3B0aW9uYWxBcHBsZXNpbXV0aWxzQ29tbWFuZENoZWNrKCkpO1xuXG5leHBvcnQge1xuICBmaXhlcywgWGNvZGVDaGVjaywgWGNvZGVDbWRMaW5lVG9vbHNDaGVjaywgRGV2VG9vbHNTZWN1cml0eUNoZWNrLFxuICBBdXRob3JpemF0aW9uRGJDaGVjaywgQ2FydGhhZ2VDaGVjaywgT3B0aW9uYWxJZGJDb21tYW5kQ2hlY2ssIE9wdGlvbmFsQXBwbGVzaW11dGlsc0NvbW1hbmRDaGVja1xufTtcbmV4cG9ydCBkZWZhdWx0IGNoZWNrcztcbiJdLCJmaWxlIjoibGliL2lvcy5qcyIsInNvdXJjZVJvb3QiOiIuLi8uLiJ9
